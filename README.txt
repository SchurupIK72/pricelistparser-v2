# Парсер прайсов / сопоставление артикулов

## Кратко
Инструмент автоматизирует сопоставление артикулов из прайс‑листов поставщиков с вашей номенклатурой. Решает частые «грязные» случаи: варианты с суффиксами (-СПЕЦМАШ / -PRO-СПЕЦМАШ), разные формы записи (дефисы / без дефисов), обрезанные коды, конструкторские точечные номера (У.036.57.000-02), «комплекты» и «наборы», ошибки кодировки (кракозябры), смешанные ячейки с несколькими артикулами через `|`, лишние цены / даты / количества в тексте.

Результат — Excel `result.xlsx` (по умолчанию) с цветовой подсветкой 100% совпадений и расширением семейства вариантов.

---
## Быстрый старт (готовый EXE)
Если у вас есть собранный файл `PriceParserGUI.exe`(он находится в папке dist):
1. Скачайте / поместите `PriceParserGUI.exe` в отдельную папку вместе с входными Excel файлами.
2. Дважды щёлкните `PriceParserGUI.exe` (либо запустите через PowerShell: `./PriceParserGUI.exe`).
3. В появившемся окне:
   - Выберите прайс клиента.
   - Выберите файл номенклатуры.
   - (Опционально)Укажите имя выходного файла (например, `result.xlsx`).
   - При необходимости измените минимальный процент совпадения.
   - Нажмите «Запустить».
4. После завершения рядом появится Excel с результатами (и листом непросопоставленных строк, если есть).

Никакой установки Python и пакетов не требуется — всё уже упаковано.

> Если Windows SmartScreen предупреждает, нажмите «Подробнее» → «Выполнить в любом случае» (файл не подписан, но безопасен если получен из доверенного источника).

---
## Возможности
- Автоматический поиск строки заголовков даже если файл без нормального header.
- Нормализация артикулов: удаление «шума», приведение регистра, сортировка токенов.
- Выделение «базового ядра» артикула без вариантных суффиксов.
- Вариантные семейства: при совпадении одного из вариантов (-СПЕЦМАШ или -PRO-СПЕЦМАШ) выводятся ВСЕ варианты (PRO, обычный, базовый) с 100%.
- Поддержка конструкторских кодов с точками (суффикс после `-NN` не срезается если есть точки внутри).
- Сопоставление форматов: `5340-1308110` ⇄ `53401308110` (цифровое «склеивание»).
- Многоступенчатый алгоритм выбора лучшего совпадения (глобально лучшее, а не «первое выше порога»).
- Приоритезация «артикульных» токенов (числовые длинные последовательности важнее брендовых слов типа СПЕЦМАШ / ЕВРО).
- Обработка комплектов / наборов: если в строке есть «комплект/набор» и числа клиента ⊆ числам артикула номенклатуры — повышаем оценку.
- Фильтрация числового шума (цены, даты, количества) с учётом происхождения токена (из «артикульной» колонки или описания).
- Сохранение коротких чисто цифровых кодов (4–5 знаков), если они пришли из колонок Артикул/Код/Номенклатура.
- Починка mojibake (кракозябр) для старых `.xls` без CODEPAGE (многостадийные попытки перекодирования cp1251/latin1/utf‑8).
- Многократная выемка артикулов из одной ячейки через разделитель `|`.
- Диагностика первых непросопоставленных строк в консоли с причинами (для отладки правил).
- GUI (Tkinter) + CLI + интерактивный режим.
- Подсветка 100% строк в Excel (зелёный фон).



---
## Установка из исходников (если нужен Python-режим)
### 1. Python
Рекомендуется Python 3.11+ (разрабатывалось и тестировалось на 3.13). Работает на Windows (PowerShell), должно работать и на Linux/Mac.

### 2. Зависимости
Установите необходимые пакеты:
```powershell
pip install pandas rapidfuzz openpyxl xlrd
```
> `xlrd` нужен для чтения старых `.xls` (движок задаётся автоматически). Для `.xlsx` используется `openpyxl`.

(Необязательно) Можно зафиксировать версии в своём `requirements.txt`.

---
## Запуск из исходников (варианты)
### Вариант 1. Графический интерфейс
```powershell
python ui_parser.py
```
Далее:
1. Выбрать файл клиента (прайс поставщика).
2. Выбрать файл номенклатуры.
3. Задать имя файла результата.
4. (Опционально) Изменить порог % совпадения.
5. Нажать «Запустить».

### Вариант 2. Командная строка (CLI)
```powershell
python parse.py --client client.xlsx --nomenclature nomen.xlsx --output result.xlsx --min-score 70
```
Параметры:
- `--client / -c` — прайс клиента.
- `--nomenclature / -n` — ваша номенклатура.
- `--output / -o` — файл результата.
- `--min-score` — минимальный процент совпадения (по умолчанию 65).

### Вариант 3. Интерактивный режим
```powershell
python parse.py -i
```
Скрипт задаст вопросы и предложит подтвердить параметры.

---
## Как должен выглядеть вход
### Номенклатура (обязательно содержит колонку `Артикул`)
Желательно также:
- Колонка с названием (распознаётся по словам: Номенк, Наимен, Назв, Товар, Опис)
- Колонка с ценой (Цена, Стоим, Price, Руб, Cost, Amount)

### Прайс клиента
Могут быть любые заголовки. Алгоритм пытается классифицировать:
- Артикульные колонки: содержат слова `артик`, `код`, `номер`, `номенк`
- Описательные: `товар`, `опис`, `наимен`, `назв`
- Количество: `кол-во`, `количество`, `qty`, `шт`, `заказ`
- Цена: `цена`, `стоим`, `price`, `руб`, `cost`, `amount`

Если не найдено ни одной «артикульной» или описательной — включается резервный режим: все столбцы считаются описательными.

---
## Алгоритм сопоставления (упрощённо по уровням)
1. Предобработка: нормализация дефисов/пробелов, починка mojibake, выемка токенов, фильтр шума.
2. Для каждого кандидата токена строятся признаки: нормализованный вид, базовое ядро без суффиксов, числовое ядро (самая длинная последовательность цифр), буквенная сигнатура, набор числовых токенов.
3. Приоритизация токенов (token_quality): длинные цифровые или смешанные >=5 символов важнее, брендовые STOPWORD_BRANDS (СПЕЦМАШ, ЕВРО …) имеют низкий приоритет.
4. Каскад поиска:
   - (0) Мгновенное совпадение по «склеенным» цифрам (удаляем всё кроме цифр) — 100%.
   - (1) Точное совпадение нормализованного артикула — 100%.
   - (1b) Совпадение базового ядра — 100%.
   - (1c) Комплект/вариант: числовые токены клиента ⊆ токенов артикула из номенклатуры; «комплект»/«набор» повышает до 100%.
   - (2) Совпадающее длинное числовое ядро + сравнение названия (WRatio по строке клиента против названия в номенклатуре).
   - (3) Общий fuzzy (rapidfuzz.WRatio) по нормализованному артикулу (с проверкой совпадения базового ядра для поднятия до 100%).
5. Выбор глобально лучшего кандидата по tuple приоритетов: (качество токена, tier, score, длина нормализованного).
6. Порог отсечения (`min_score`). Если достигнут — формирование строки результата.
7. Вариантное расширение: если совпадение 100% ИЛИ найден вариант с хвостом -СПЕЦМАШ / -PRO-СПЕЦМАШ — все члены семейства (PRO → СПЕЦМАШ → базовый) добавляются с 100%.
8. Fallback: если ничего не выбрано, ещё одна попытка fuzzy по объединённому тексту строки.
9. Диагностика первых 50 непросопоставленных строк (причина: нет токенов, score ниже порога и т.д.).

---
## Выходной файл (столбцы)
Новый порядок первых ключевых столбцов оптимизирован под просмотр итогов без прокрутки:
| Столбец | Описание |
|---------|----------|
|Номер строки из заказа|
| Исходные тексты | Сырые тексты всех ячеек строки (после деления по `|`) |
| Совпадение (из номенклатуры) | Найденный артикул из базы |
| Название (из номенклатуры) | Наименование товара (если колонка найдена) |
| Цена | Цена (приоритет: из номенклатуры → из прайса клиента) |
| Количество (из заказа) | Значение количества если найдено |
| Процент совпадения | Итоговый (возможно повышенный) процент совпадения |
| Нормализованный артикул совпадения | Нормализованный вид артикула из базы |
| Извлеченный артикул | Токен клиента, давший лучшее совпадение |
| Нормализованный артикул клиента | Нормализованный вид исходного токена клиента |
| Сырой процент совпадения | Процент ДО возможного повышения (raw score) |

Строки с 100% подсвечены зелёным. «Сырой процент совпадения» позволяет увидеть, был ли аплифт (например при расширении семейства вариантов или комплете).
Строки семейств(несколько совпадений (без хвоста,с хвостом -СПЕЦМAШ и -PRO-СПЕЦМAШ)) подсвечены темнозеленым
---
## Итоговый vs сырой процент
- Сырой: результат непосредственного сопоставления выбранного варианта.
- Итоговый: может быть повышен до 100% при: точном базовом совпадении, расширении семейства (-СПЕЦМАШ/-PRO-СПЕЦМАШ), комплектном включении.
- Если итог > сырого и =100 — значит сработало одно из правил повышения.

---
## Константы и настройка (в начале `parse.py`)
| Константа | Назначение |
|-----------|-----------|
| `DEFAULT_MIN_MATCH_SCORE` | Порог совпадения по умолчанию (CLI можно переопределить) |
| `FILTER_NUMERIC_NOISE` | Включить фильтрацию числового мусора (цены/даты) |
| `AUTO_FIX_MOJIBAKE` | Попытки восстановления кириллицы при битой кодировке |
| `DIAG_COLLECT_UNMATCHED` | Собирает причины непросопоставленных строк (печать в консоль) |
| `STOPWORD_BRANDS` | Множество брендовых слов с пониженным приоритетом |
| `PURE_NUMERIC_MIN_KEEP` | Минимальная длина чисто цифр токена (если не из артикульной колонки) |
| `OUTPUT_COLUMNS` | Порядок и состав столбцов вывода |
| `RAW_SCORE_COLUMN` | Имя колонки с сырым score |
| `ENABLE_KEYWORD_GUARD` | Включить защиту по ключевым словам (семантический фильтр) |
| `KEYWORD_MIN_KEY_LEN` | Мин. длина слова, чтобы считаться ключом |
| `KEYWORD_REQUIRED_OVERLAP` | Сколько ключей минимум должно совпасть |
| `KEYWORD_ALLOW_IF_NAME_SIM` | Допуск без ключей при высокой схожести названия |
| `KEYWORD_STOPWORDS` | Стоп-слова (не считаются ключами) |

> Можно изменить прямо в коде перед запуском. Для более гибкой настройки можно добавить чтение внешнего YAML/JSON (см. Раздел Roadmap).

---
## Типичные сценарии
1. «Хочу увидеть все варианты артикулов для -СПЕЦМАШ» — просто запустите: при нахождении одного варианта получите три строки (PRO, СПЕЦМАШ, базовый) с 100%.
2. «В файле странные символы ÃÐ…» — оставьте `AUTO_FIX_MOJIBAKE = True`.
3. «Ловит цену вместо артикула» — убедитесь, что колонка с артикулами названа понятно (Артикул / Код / Наименование). Можно поднять `PURE_NUMERIC_MIN_KEEP`.
4. «Нужно ослабить/усилить чувствительность» — измените `--min-score` или `DEFAULT_MIN_MATCH_SCORE`.
5. «Нужны только точные совпадения» — запустите с `--min-score 100`.

---
## Диагностика
В консоли после выполнения может появиться блок:
```
[DIAG] Непросопоставленных строк: 7 (показаны первые 7)
[DIAG] reason= best_score=62<min_score  raw= ...  extracted= ['...']
```
Причины:
- `no_tokens_extracted` — не удалось достать ни одного кандидата.
- `best_score=.. <min_score` — лучший найденный ниже порога.
- `fallback_wratio=.. <min_score` — не помог общий fuzzy по всей строке.
- `no_candidate_after_filters` — всё отфильтровано как шум.
Используйте это, чтобы решить: снизить порог, поправить названия колонок или расширить алгоритм.

---
## Ограничения и известные моменты
- Семейства вариантов зашиты только для суффиксов -СПЕЦМАШ и -PRO-СПЕЦМАШ.
- Не создаёт отдельный лист с диагностикой (только консоль).
- Нет внешнего файла конфигурации (всё через константы в коде).
- При дубликатах нормализованного артикула берётся первый.

---
## Roadmap (предложения по развитию)
- Внешний config (YAML/JSON) для порогов, стоп-слов, суффиксов.
- Расширение семейства суффиксов (РК, СБ, -Х, -Вxx и т.п.).
- Запись диагностик на отдельный лист Excel.
- Классификация типа найденного совпадения (точный / базовое ядро / комплект / fuzzy).
- Логирование (уровни DEBUG/INFO/WARN) вместо печати.
- Пакетное сопоставление нескольких прайсов в одной сессии.

---
## FAQ
**Q:** Нужно ли сортировать/чистить входные файлы?  
**A:** Нет, алгоритм сам ищет заголовки и нормализует данные.

**Q:** Что делать если GUI «не отвечает»?  
**A:** Обработка идёт в отдельном потоке; дождитесь завершения либо смотрите прогресс в текстовом поле.

**Q:** Можно ли отключить расширение вариантов?  
**A:** Закомментируйте блок в `main_process` с проверкой `if best_score == 100 or art_name_upper.endswith(...)`.

**Q:** Как добавить новый суффикс семейства?  
**A:** Добавьте в регулярку `SPEC_VARIANT_RE = re.compile(...)` и обновите функцию `variant_rank`.


---
## Лицензия
MIT License 

---
## Обратная связь
schurupik72@gmail.com
